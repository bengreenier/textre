{"version":3,"sources":["add-source.tsx","add-regex.tsx","graph.tsx","util.ts","intro.tsx","app.tsx","index.tsx"],"names":["AddSource","props","buttonRef","React","handleChange","ev","current","disabled","style","backgroundColor","files","target","proms","i","file","push","text","then","data","console","log","length","registerSource","name","Promise","all","handleDone","onComplete","type","multiple","onChange","accept","ref","onClick","AddRegex","textRef","flagsRef","markerRef","useLocalStorage","recentListRaw","setRecentListRaw","recentList","JSON","parse","textEl","textContent","getAttribute","value","flagContent","markerFlag","checked","RegExp","e","src","regex","flags","marker","undefined","find","stringify","concat","placeholder","defaultValue","display","sources","map","re","key","fontWeight","entry","data-regex","data-flags","data-marker","readOnly","width","currentTarget","href","rel","colors","Graph","inflatedRegexes","regexes","rex","_marker","flatten","datasources","s","relevantLines","split","delim","filter","line","some","test","j","colorId","splits","isMarker","exec","groups","time","plot","meta","x","y","parseRegexResult","chunk","c","Object","keys","k","splitColorId","label","fill","showLine","borderColor","d","position","maxHeight","datasets","options","downsample","onInit","restoreOriginalData","enabled","threshold","animation","duration","tooltips","callbacks","tooltipItem","datasetIndex","index","Math","round","yLabel","scales","xAxes","distribution","offset","ticks","major","fontStyle","source","autoSkip","autoSkipPadding","maxRotation","sampleSize","yAxes","gridLines","drawBorder","scaleLabel","Intro","App","isOOBE","setIsOOBE","addSourceVisible","setAddSourceVisible","addRegexVisible","setAddRegexVisible","dataSources","setDataSources","setRegexes","addSource","addRegex","rootElement","document","getElementById","render"],"mappings":"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","file":"static/js/main.123efbbe.chunk.js","sourcesContent":["import * as React from \"react\";\r\n\r\ninterface Props {\r\n  registerSource: (name: string, data: string) => void;\r\n  onComplete: () => void;\r\n}\r\n\r\nexport default function AddSource(props: Props) {\r\n  const buttonRef = React.useRef<HTMLButtonElement>(null);\r\n\r\n  const handleChange = React.useCallback(\r\n    (ev: React.ChangeEvent<HTMLInputElement>) => {\r\n      if (buttonRef.current) {\r\n        buttonRef.current.disabled = true;\r\n        buttonRef.current.style.backgroundColor = \"red\";\r\n      }\r\n\r\n      const files = ev.target.files;\r\n      if (files == null) {\r\n        return;\r\n      }\r\n\r\n      const proms: Promise<void>[] = [];\r\n\r\n      for (let i = 0; i < files.length; i++) {\r\n        const file = files[i];\r\n\r\n        proms.push(\r\n          file.text().then((data) => {\r\n            console.log(data.length);\r\n            props.registerSource(file.name, data);\r\n          })\r\n        );\r\n      }\r\n\r\n      Promise.all(proms).then(() => {\r\n        if (buttonRef.current) {\r\n          buttonRef.current.disabled = false;\r\n          buttonRef.current.style.backgroundColor = \"\";\r\n        }\r\n      });\r\n    },\r\n    [props]\r\n  );\r\n\r\n  const handleDone = React.useCallback(() => {\r\n    props.onComplete();\r\n  }, [props]);\r\n\r\n  return (\r\n    <div>\r\n      <h2>\r\n        Add a source <small>Select your file(s)</small>\r\n      </h2>\r\n      <input type=\"file\" multiple onChange={handleChange} accept=\".txt\"></input>\r\n      <br />\r\n      <button ref={buttonRef} onClick={handleDone}>\r\n        Close\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n","import * as React from \"react\";\r\nimport useLocalStorage from \"react-use-localstorage\";\r\nimport { RegexSource } from \"./types\";\r\n\r\ninterface Props {\r\n  sources: RegexSource[];\r\n  registerSource: (src: RegexSource) => void;\r\n  onComplete: () => void;\r\n}\r\n\r\nexport default function AddRegex(props: Props) {\r\n  const textRef = React.useRef<HTMLInputElement>(null);\r\n  const flagsRef = React.useRef<HTMLInputElement>(null);\r\n  const markerRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const [recentListRaw, setRecentListRaw] = useLocalStorage(\r\n    \"recent-regex\",\r\n    \"[]\"\r\n  );\r\n\r\n  const recentList = React.useMemo<RegexSource[]>(() => {\r\n    return JSON.parse(recentListRaw);\r\n  }, [recentListRaw]);\r\n\r\n  const handleDone = React.useCallback(\r\n    (textEl: HTMLInputElement | null) => {\r\n      if (!textEl || !flagsRef.current || !markerRef.current) {\r\n        return;\r\n      }\r\n\r\n      const textContent = textEl.getAttribute(\"data-regex\") || textEl.value;\r\n      const flagContent =\r\n        textEl.getAttribute(\"data-flags\") || flagsRef.current.value;\r\n      let markerFlag =\r\n        textEl.getAttribute(\"data-marker\") || markerRef.current.checked;\r\n\r\n      if (typeof markerFlag === \"string\") {\r\n        markerFlag = markerFlag === \"true\";\r\n      }\r\n\r\n      try {\r\n        // ensure it isn't garbage\r\n        new RegExp(textContent, flagContent);\r\n      } catch (e) {\r\n        // TODO(bengreenier): tell em it's bad re\r\n        return;\r\n      }\r\n\r\n      const src = {\r\n        regex: textContent,\r\n        flags: flagContent,\r\n        marker: markerFlag\r\n      };\r\n      console.log(src);\r\n      props.registerSource(src);\r\n\r\n      if (\r\n        recentList.find(\r\n          (e) =>\r\n            e.regex === src.regex &&\r\n            e.flags === src.flags &&\r\n            e.marker === src.marker\r\n        ) === undefined\r\n      ) {\r\n        setRecentListRaw(JSON.stringify(recentList.concat([src])));\r\n      }\r\n\r\n      props.onComplete();\r\n    },\r\n    [props, recentList, setRecentListRaw]\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <h2>Add a regex</h2>\r\n      <input ref={textRef} type=\"text\" placeholder=\"regex\" />\r\n      <input ref={flagsRef} type=\"text\" placeholder=\"flags\" defaultValue=\"i\" />\r\n      <p style={{ display: \"inline\" }}>Is Marker: </p>\r\n      <input ref={markerRef} type=\"checkbox\" />\r\n      <br />\r\n      <button onClick={() => handleDone(textRef.current)}>Add</button>\r\n      <button onClick={() => props.onComplete()}>Close</button>\r\n      <h3>Current regexes</h3>\r\n      {props.sources.map((re, i) => {\r\n        return (\r\n          <p key={re.regex + re.marker}>\r\n            <span style={{ fontWeight: \"bold\" }}>{i}</span>\r\n            {\" - \"}\r\n            {re.regex}\r\n          </p>\r\n        );\r\n      })}\r\n      <h3>Recent regexes</h3>\r\n      {recentList.map((entry: RegexSource) => (\r\n        <input\r\n          data-regex={entry.regex}\r\n          data-flags={entry.flags}\r\n          data-marker={entry.marker}\r\n          key={entry.regex + entry.flags + entry.marker}\r\n          type=\"text\"\r\n          readOnly\r\n          value={\r\n            \"/\" +\r\n            entry.regex +\r\n            \"/\" +\r\n            entry.flags +\r\n            \" (isMarker: \" +\r\n            entry.marker +\r\n            \")\"\r\n          }\r\n          style={{ width: \"100%\" }}\r\n          onClick={(ev) => handleDone(ev.currentTarget)}\r\n        />\r\n      ))}\r\n      <h3>Requirements/Tips</h3>\r\n      <ul>\r\n        <li>\r\n          <p>\r\n            <span style={{ fontWeight: \"bold\" }}>time</span>\r\n            {\", and \"}\r\n            <span style={{ fontWeight: \"bold\" }}>plot</span> are required{\" \"}\r\n            <a\r\n              href=\"https://javascript.info/regexp-groups#named-groups\"\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n            >\r\n              named capture groups\r\n            </a>\r\n            . They inform us how to find the time series data.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <span style={{ fontWeight: \"bold\" }}>split</span> is an optional{\" \"}\r\n            <a\r\n              href=\"https://javascript.info/regexp-groups#named-groups\"\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n            >\r\n              named capture group\r\n            </a>\r\n            . It allows optional splitting of series by some identifier.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            All other matches are captured as metadata, and included in the\r\n            hover tooltip for each data point.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>The named capture group syntax is as follows: </p>\r\n          <pre>\r\n            (?&lt;time&gt;)\r\n            <br />\r\n            (?&lt;plot&gt;)\r\n            <br />\r\n            (?&lt;split&gt;)\r\n          </pre>\r\n        </li>\r\n        <li>\r\n          <pre style={{ display: \"inline\" }}>\\s(?&lt;time&gt;.+?)\\s</pre>\r\n          <p style={{ display: \"inline\" }}>\r\n            is a named capture group to select{\" \"}\r\n            <span style={{ fontWeight: \"bold\" }}>time</span> as all characters\r\n            between two instances of whitespace.\r\n          </p>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n","import * as React from \"react\";\r\nimport { Line } from \"react-chartjs-2\";\r\nimport { flatten } from \"array-flatten\";\r\nimport { DataSource, RegexSource, RegExpWithMarker } from \"./types\";\r\nimport { parseRegexResult } from \"./util\";\r\n\r\nimport \"chartjs-plugin-downsample\";\r\n\r\ninterface Props {\r\n  datasources: DataSource[];\r\n  regexes: RegexSource[];\r\n  delim: string;\r\n}\r\n\r\nconst colors = [\r\n  \"#0f6fc6\",\r\n  \"#009dd9\",\r\n  \"#0bd0d9\",\r\n  \"#10cf9b\",\r\n  \"#7cca62\",\r\n  \"#a5c249\",\r\n  \"#9999ff\",\r\n  \"#993366\",\r\n  \"#ffffcc\",\r\n  \"#ccffff\",\r\n  \"#660066\",\r\n  \"#ff8080\",\r\n  \"#0066cc\",\r\n  \"#ccccff\",\r\n  \"#000080\",\r\n  \"#ff00ff\",\r\n  \"#ffff00\",\r\n  \"#0000ff\",\r\n  \"#800080\",\r\n  \"#800000\",\r\n  \"#008080\",\r\n  \"#0000ff\",\r\n  \"#f8c000\",\r\n  \"#f88600\",\r\n  \"#f83500\",\r\n  \"#8b723d\",\r\n  \"#818b3d\",\r\n  \"#586215\"\r\n];\r\n\r\nexport default function Graph(props: Props) {\r\n  React.useEffect(() => {});\r\n  const data = React.useMemo(() => {\r\n    const inflatedRegexes = props.regexes.map((re) => {\r\n      const rex = new RegExp(re.regex, re.flags) as RegExpWithMarker;\r\n      rex._marker = re.marker || false;\r\n      return rex;\r\n    });\r\n\r\n    return flatten(\r\n      props.datasources.map((s, i) => {\r\n        const relevantLines = s.data\r\n          .split(props.delim)\r\n          .filter((line) => inflatedRegexes.some((regex) => regex.test(line)));\r\n\r\n        return inflatedRegexes.map((re, j) => {\r\n          // a colorid is a unique 0-based int that we use to pic a unique color for the visual\r\n          const colorId = i + j;\r\n          const splits: { [key: string]: boolean } = {};\r\n          let isMarker = false;\r\n          const data = relevantLines\r\n            .map((line) => {\r\n              return parseRegexResult(re, line);\r\n            })\r\n            .map((chunk) => {\r\n              if (!chunk) {\r\n                // bad chunk, gtfo - parse failed\r\n                return undefined;\r\n              }\r\n\r\n              // record that there's a split, if there is one\r\n              if (chunk.split && !splits[chunk.split]) {\r\n                splits[chunk.split] = true;\r\n              }\r\n\r\n              // if it's a marker, lets plot it @ zero\r\n              if (chunk.marker === true) {\r\n                chunk.y = \"-1\";\r\n                isMarker = true;\r\n              }\r\n\r\n              // a single data point is a t, y pair\r\n              return chunk;\r\n            })\r\n            // remove any \"bad eggs\"\r\n            .filter((c) => c !== undefined);\r\n\r\n          // there's no splits, but we can fake one to keep the upcoming logic cleaner\r\n          if (Object.keys(splits).length === 0) {\r\n            splits[\"\"] = true;\r\n          }\r\n\r\n          return Object.keys(splits).map((split, k) => {\r\n            // recalc a color id, factoring in the split offsets\r\n            const splitColorId = colorId + k;\r\n\r\n            return {\r\n              label: `${s.name} [${j}] ${split}`,\r\n              fill: false,\r\n              showLine: isMarker === false,\r\n              borderColor: colors[splitColorId],\r\n              backgroundColor: colors[splitColorId],\r\n              // is this a real split or nah (short-circuit)\r\n              data:\r\n                split === \"\"\r\n                  ? data\r\n                  : data.filter((d) => d && d.split && d.split === split)\r\n            };\r\n          });\r\n        });\r\n      })\r\n    );\r\n  }, [props]);\r\n\r\n  // render the line graph\r\n  return (\r\n    <div style={{ position: \"relative\", maxHeight: \"100vh\" }}>\r\n      <Line\r\n        data={{ datasets: data }}\r\n        options={{\r\n          downsample: {\r\n            onInit: false,\r\n            restoreOriginalData: false,\r\n            enabled: true,\r\n            threshold: 500 // max number of points to display per dataset\r\n          },\r\n          animation: {\r\n            duration: 0\r\n          },\r\n          tooltips: {\r\n            callbacks: {\r\n              label: function (tooltipItem: any, data: any) {\r\n                var label = data.datasets[tooltipItem.datasetIndex].label || \"\";\r\n                var meta =\r\n                  data.datasets[tooltipItem.datasetIndex].data[\r\n                    tooltipItem.index\r\n                  ].meta;\r\n\r\n                if (label) {\r\n                  label += \": \";\r\n                }\r\n\r\n                if (meta) {\r\n                  label += JSON.stringify(meta) + \": \";\r\n                }\r\n\r\n                label += Math.round(tooltipItem.yLabel * 100) / 100;\r\n                return label;\r\n              }\r\n            }\r\n          },\r\n          scales: {\r\n            xAxes: [\r\n              {\r\n                type: \"time\",\r\n                distribution: \"series\",\r\n                offset: true,\r\n                ticks: {\r\n                  major: {\r\n                    enabled: true,\r\n                    fontStyle: \"bold\"\r\n                  },\r\n                  source: \"data\",\r\n                  autoSkip: true,\r\n                  autoSkipPadding: 75,\r\n                  maxRotation: 0,\r\n                  sampleSize: 100\r\n                }\r\n              }\r\n            ],\r\n            yAxes: [\r\n              {\r\n                gridLines: {\r\n                  drawBorder: false\r\n                },\r\n                scaleLabel: {\r\n                  display: false\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","import { RegexResult, RegExpWithMarker } from \"./types\";\r\n\r\nexport const parseRegexResult = (\r\n  rex: RegExpWithMarker,\r\n  line: string\r\n): RegexResult | undefined => {\r\n  const re = rex.exec(line);\r\n\r\n  // markers don't need plot!\r\n  if (\r\n    !re ||\r\n    !re.groups ||\r\n    !re.groups.time ||\r\n    (!re.groups.plot && !rex._marker)\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  const { time, plot, split } = re.groups;\r\n  const meta: string[] = [];\r\n\r\n  for (let i = 1; i < re.length; i++) {\r\n    // skip data that's in a named group\r\n    if (\r\n      typeof re[i] !== \"undefined\" &&\r\n      (re[i] === time || re[i] === plot || re[i] === split)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    meta.push(re[i]);\r\n  }\r\n\r\n  const res: RegexResult = {\r\n    x: time,\r\n    y: plot,\r\n    split,\r\n    marker: rex._marker || false,\r\n    meta: meta.length > 0 ? meta : undefined\r\n  };\r\n\r\n  return res;\r\n};\r\n","import * as React from \"react\";\r\n\r\ninterface Props {\r\n  onComplete: () => void;\r\n}\r\n\r\nexport default function Intro(props: Props) {\r\n  return (\r\n    <div>\r\n      <h1>Welcome to Textre!</h1>\r\n      <p>\r\n        Textre (pronounced texture) is a tool for extracting time series data\r\n        from raw text files, and visualizing it on a graph. I built it to help\r\n        me debug audio video call logs - but feel free to use it for whatever.\r\n      </p>\r\n      <h3>Getting Started</h3>\r\n      <ul>\r\n        <li>\r\n          <p>\r\n            First, you'll be asked to select a{\" \"}\r\n            <span style={{ fontWeight: \"bold\" }}>source</span> - sources are\r\n            just raw text files containing the content you want to select and\r\n            visualize.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            Then you'll define some{\" \"}\r\n            <span style={{ fontWeight: \"bold\" }}>regex</span> - regex tells us\r\n            how to understand your content.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            That's it! You'll be presented with{\" \"}\r\n            <span style={{ fontWeight: \"bold\" }}>the chart</span> - the chart is\r\n            the main view in this app, it shows all your time series data and\r\n            lets you interact with it.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <button onClick={() => props.onComplete()}>Begin!</button>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n","import * as React from \"react\";\nimport AddSource from \"./add-source\";\nimport AddRegex from \"./add-regex\";\nimport Graph from \"./graph\";\nimport Intro from \"./intro\";\nimport { DataSource, RegexSource } from \"./types\";\n\nimport \"./styles.css\";\n\nexport default function App() {\n  const [isOOBE, setIsOOBE] = React.useState<boolean>(true);\n  const [addSourceVisible, setAddSourceVisible] = React.useState<boolean>(true);\n  const [addRegexVisible, setAddRegexVisible] = React.useState<boolean>(true);\n  const [dataSources, setDataSources] = React.useState<DataSource[]>([]);\n  const [regexes, setRegexes] = React.useState<RegexSource[]>([]);\n\n  const addSource = React.useCallback(\n    (name: string, data: string) => {\n      setDataSources(dataSources.concat({ name, data }));\n    },\n    [dataSources]\n  );\n\n  const addRegex = React.useCallback(\n    (src: RegexSource) => {\n      setRegexes(regexes.concat([src]));\n    },\n    [regexes]\n  );\n\n  if (isOOBE) {\n    return <Intro onComplete={() => setIsOOBE(false)} />;\n  } else if (addSourceVisible) {\n    return (\n      <AddSource\n        registerSource={addSource}\n        onComplete={() => setAddSourceVisible(false)}\n      />\n    );\n  } else if (addRegexVisible) {\n    return (\n      <AddRegex\n        sources={regexes}\n        registerSource={addRegex}\n        onComplete={() => setAddRegexVisible(false)}\n      />\n    );\n  } else {\n    return (\n      <>\n        <div>\n          <span>\n            <button onClick={() => setAddSourceVisible(true)}>\n              Add Source [{dataSources.length}]\n            </button>\n          </span>\n          <span>\n            <button onClick={() => setAddRegexVisible(true)}>\n              Add Regex [{regexes.length}]\n            </button>\n          </span>\n          <span>\n            <button onClick={() => setRegexes([])}>Clear Regex</button>\n          </span>\n        </div>\n        <Graph datasources={dataSources} regexes={regexes} delim={\"\\n\"} />\n      </>\n    );\n  }\n}\n","import * as React from \"react\";\nimport { render } from \"react-dom\";\n\nimport App from \"./app\";\n\nconst rootElement = document.getElementById(\"root\");\nrender(<App />, rootElement);\n"],"sourceRoot":""}