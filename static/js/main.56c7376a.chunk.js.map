{"version":3,"sources":["add-source.tsx","add-regex.tsx","graph.tsx","util.ts","intro.tsx","app.tsx","index.tsx"],"names":["AddSource","props","registerSources","onComplete","buttonRef","React","handleChange","ev","current","disabled","style","backgroundColor","files","target","proms","loadSource","fl","a","text","data","name","i","length","push","Promise","all","then","sources","handleDone","type","multiple","onChange","accept","ref","onClick","AddRegex","textRef","flagsRef","markerRef","useLocalStorage","recentListRaw","setRecentListRaw","recentList","JSON","parse","textEl","textContent","getAttribute","value","flagContent","markerFlag","checked","RegExp","e","src","regex","flags","marker","console","log","registerSource","undefined","find","stringify","concat","placeholder","defaultValue","display","map","re","key","fontWeight","entry","data-regex","data-flags","data-marker","readOnly","width","currentTarget","href","rel","colors","Graph","inflatedRegexes","regexes","rex","_marker","flatten","datasources","s","relevantLines","split","delim","filter","line","some","test","j","colorId","splits","isMarker","exec","groups","time","plot","meta","x","moment","toDate","y","parseRegexResult","chunk","c","Object","keys","k","splitColorId","label","fill","showLine","borderColor","d","position","maxHeight","datasets","options","downsample","onInit","restoreOriginalData","enabled","threshold","animation","duration","tooltips","callbacks","tooltipItem","datasetIndex","index","Math","round","yLabel","scales","xAxes","distribution","offset","ticks","major","fontStyle","source","autoSkip","autoSkipPadding","maxRotation","sampleSize","yAxes","gridLines","drawBorder","scaleLabel","Intro","App","isOOBE","setIsOOBE","addSourceVisible","setAddSourceVisible","addRegexVisible","setAddRegexVisible","dataSources","setDataSources","setRegexes","addSources","srcs","addRegex","rootElement","document","getElementById","render"],"mappings":"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","file":"static/js/main.56c7376a.chunk.js","sourcesContent":["import * as React from \"react\";\r\n\r\ninterface Props {\r\n  registerSources: (srcs: { name: string; data: string }[]) => void;\r\n  onComplete: () => void;\r\n}\r\n\r\nexport default function AddSource(props: Props) {\r\n  const { registerSources, onComplete } = props;\r\n  const buttonRef = React.useRef<HTMLButtonElement>(null);\r\n\r\n  const handleChange = React.useCallback(\r\n    (ev: React.ChangeEvent<HTMLInputElement>) => {\r\n      if (buttonRef.current) {\r\n        buttonRef.current.disabled = true;\r\n        buttonRef.current.style.backgroundColor = \"red\";\r\n      }\r\n\r\n      const files = ev.target.files;\r\n      if (files == null) {\r\n        return;\r\n      }\r\n\r\n      const proms: Promise<{ name: string; data: string }>[] = [];\r\n\r\n      const loadSource = async (fl: File) => {\r\n        const data = await fl.text();\r\n        return { name: fl.name, data };\r\n      };\r\n\r\n      for (let i = 0; i < files.length; i++) {\r\n        proms.push(loadSource(files[i]));\r\n      }\r\n\r\n      Promise.all(proms).then((sources) => {\r\n        registerSources(sources);\r\n\r\n        if (buttonRef.current) {\r\n          buttonRef.current.disabled = false;\r\n          buttonRef.current.style.backgroundColor = \"\";\r\n        }\r\n      });\r\n    },\r\n    [registerSources]\r\n  );\r\n\r\n  const handleDone = React.useCallback(() => {\r\n    onComplete();\r\n  }, [onComplete]);\r\n\r\n  return (\r\n    <div>\r\n      <h2>\r\n        Add a source <small>Select your file(s)</small>\r\n      </h2>\r\n      <input type=\"file\" multiple onChange={handleChange} accept=\".txt\"></input>\r\n      <br />\r\n      <button ref={buttonRef} onClick={handleDone}>\r\n        Close\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n","import * as React from \"react\";\r\nimport useLocalStorage from \"react-use-localstorage\";\r\nimport { RegexSource } from \"./types\";\r\n\r\ninterface Props {\r\n  sources: RegexSource[];\r\n  registerSource: (src: RegexSource) => void;\r\n  onComplete: () => void;\r\n}\r\n\r\nexport default function AddRegex(props: Props) {\r\n  const textRef = React.useRef<HTMLInputElement>(null);\r\n  const flagsRef = React.useRef<HTMLInputElement>(null);\r\n  const markerRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const [recentListRaw, setRecentListRaw] = useLocalStorage(\r\n    \"recent-regex\",\r\n    \"[]\"\r\n  );\r\n\r\n  const recentList = React.useMemo<RegexSource[]>(() => {\r\n    return JSON.parse(recentListRaw);\r\n  }, [recentListRaw]);\r\n\r\n  const handleDone = React.useCallback(\r\n    (textEl: HTMLInputElement | null) => {\r\n      if (!textEl || !flagsRef.current || !markerRef.current) {\r\n        return;\r\n      }\r\n\r\n      const textContent = textEl.getAttribute(\"data-regex\") || textEl.value;\r\n      const flagContent =\r\n        textEl.getAttribute(\"data-flags\") || flagsRef.current.value;\r\n      let markerFlag =\r\n        textEl.getAttribute(\"data-marker\") || markerRef.current.checked;\r\n\r\n      if (typeof markerFlag === \"string\") {\r\n        markerFlag = markerFlag === \"true\";\r\n      }\r\n\r\n      try {\r\n        // ensure it isn't garbage\r\n        new RegExp(textContent, flagContent);\r\n      } catch (e) {\r\n        // TODO(bengreenier): tell em it's bad re\r\n        return;\r\n      }\r\n\r\n      const src = {\r\n        regex: textContent,\r\n        flags: flagContent,\r\n        marker: markerFlag\r\n      };\r\n      console.log(src);\r\n      props.registerSource(src);\r\n\r\n      if (\r\n        recentList.find(\r\n          (e) =>\r\n            e.regex === src.regex &&\r\n            e.flags === src.flags &&\r\n            e.marker === src.marker\r\n        ) === undefined\r\n      ) {\r\n        setRecentListRaw(JSON.stringify(recentList.concat([src])));\r\n      }\r\n\r\n      props.onComplete();\r\n    },\r\n    [props, recentList, setRecentListRaw]\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <h2>Add a regex</h2>\r\n      <input ref={textRef} type=\"text\" placeholder=\"regex\" />\r\n      <input ref={flagsRef} type=\"text\" placeholder=\"flags\" defaultValue=\"i\" />\r\n      <p style={{ display: \"inline\" }}>Is Marker: </p>\r\n      <input ref={markerRef} type=\"checkbox\" />\r\n      <br />\r\n      <button onClick={() => handleDone(textRef.current)}>Add</button>\r\n      <button onClick={() => props.onComplete()}>Close</button>\r\n      <h3>Current regexes</h3>\r\n      {props.sources.map((re, i) => {\r\n        return (\r\n          <p key={re.regex + re.marker}>\r\n            <span style={{ fontWeight: \"bold\" }}>{i}</span>\r\n            {\" - \"}\r\n            {re.regex}\r\n          </p>\r\n        );\r\n      })}\r\n      <h3>Recent regexes</h3>\r\n      {recentList.map((entry: RegexSource) => (\r\n        <input\r\n          data-regex={entry.regex}\r\n          data-flags={entry.flags}\r\n          data-marker={entry.marker}\r\n          key={entry.regex + entry.flags + entry.marker}\r\n          type=\"text\"\r\n          readOnly\r\n          value={\r\n            \"/\" +\r\n            entry.regex +\r\n            \"/\" +\r\n            entry.flags +\r\n            \" (isMarker: \" +\r\n            entry.marker +\r\n            \")\"\r\n          }\r\n          style={{ width: \"100%\" }}\r\n          onClick={(ev) => handleDone(ev.currentTarget)}\r\n        />\r\n      ))}\r\n      <h3>Requirements/Tips</h3>\r\n      <ul>\r\n        <li>\r\n          <p>\r\n            <span style={{ fontWeight: \"bold\" }}>time</span>\r\n            {\", and \"}\r\n            <span style={{ fontWeight: \"bold\" }}>plot</span> are required{\" \"}\r\n            <a\r\n              href=\"https://javascript.info/regexp-groups#named-groups\"\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n            >\r\n              named capture groups\r\n            </a>\r\n            . They inform us how to find the time series data.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <span style={{ fontWeight: \"bold\" }}>split</span> is an optional{\" \"}\r\n            <a\r\n              href=\"https://javascript.info/regexp-groups#named-groups\"\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n            >\r\n              named capture group\r\n            </a>\r\n            . It allows optional splitting of series by some identifier.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            All other matches are captured as metadata, and included in the\r\n            hover tooltip for each data point.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>The named capture group syntax is as follows: </p>\r\n          <pre>\r\n            (?&lt;time&gt;)\r\n            <br />\r\n            (?&lt;plot&gt;)\r\n            <br />\r\n            (?&lt;split&gt;)\r\n          </pre>\r\n        </li>\r\n        <li>\r\n          <pre style={{ display: \"inline\" }}>\\s(?&lt;time&gt;.+?)\\s</pre>\r\n          <p style={{ display: \"inline\" }}>\r\n            is a named capture group to select{\" \"}\r\n            <span style={{ fontWeight: \"bold\" }}>time</span> as all characters\r\n            between two instances of whitespace.\r\n          </p>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n","import * as React from \"react\";\r\nimport { Line } from \"react-chartjs-2\";\r\nimport { flatten } from \"array-flatten\";\r\nimport { DataSource, RegexSource, RegExpWithMarker } from \"./types\";\r\nimport { parseRegexResult } from \"./util\";\r\n\r\nimport \"chartjs-plugin-downsample\";\r\n\r\ninterface Props {\r\n  datasources: DataSource[];\r\n  regexes: RegexSource[];\r\n  delim: string;\r\n}\r\n\r\nconst colors = [\r\n  \"#0f6fc6\",\r\n  \"#009dd9\",\r\n  \"#0bd0d9\",\r\n  \"#10cf9b\",\r\n  \"#7cca62\",\r\n  \"#a5c249\",\r\n  \"#9999ff\",\r\n  \"#993366\",\r\n  \"#ffffcc\",\r\n  \"#ccffff\",\r\n  \"#660066\",\r\n  \"#ff8080\",\r\n  \"#0066cc\",\r\n  \"#ccccff\",\r\n  \"#000080\",\r\n  \"#ff00ff\",\r\n  \"#ffff00\",\r\n  \"#0000ff\",\r\n  \"#800080\",\r\n  \"#800000\",\r\n  \"#008080\",\r\n  \"#0000ff\",\r\n  \"#f8c000\",\r\n  \"#f88600\",\r\n  \"#f83500\",\r\n  \"#8b723d\",\r\n  \"#818b3d\",\r\n  \"#586215\",\r\n];\r\n\r\nexport default function Graph(props: Props) {\r\n  React.useEffect(() => {});\r\n  const data = React.useMemo(() => {\r\n    const inflatedRegexes = props.regexes.map((re) => {\r\n      const rex = new RegExp(re.regex, re.flags) as RegExpWithMarker;\r\n      rex._marker = re.marker || false;\r\n      return rex;\r\n    });\r\n\r\n    return flatten(\r\n      props.datasources.map((s, i) => {\r\n        const relevantLines = s.data\r\n          .split(props.delim)\r\n          .filter((line) => inflatedRegexes.some((regex) => regex.test(line)));\r\n\r\n        return inflatedRegexes.map((re, j) => {\r\n          // a colorid is a unique 0-based int that we use to pic a unique color for the visual\r\n          const colorId = i + j;\r\n          const splits: { [key: string]: boolean } = {};\r\n          let isMarker = false;\r\n          const data = relevantLines\r\n            .map((line) => {\r\n              return parseRegexResult(re, line);\r\n            })\r\n            .map((chunk) => {\r\n              if (!chunk) {\r\n                // bad chunk, gtfo - parse failed\r\n                return undefined;\r\n              }\r\n\r\n              // record that there's a split, if there is one\r\n              if (chunk.split && !splits[chunk.split]) {\r\n                splits[chunk.split] = true;\r\n              }\r\n\r\n              // if it's a marker, lets plot it @ zero\r\n              if (chunk.marker === true) {\r\n                chunk.y = \"-1\";\r\n                isMarker = true;\r\n              }\r\n\r\n              // a single data point is a t, y pair\r\n              return chunk;\r\n            })\r\n            // remove any \"bad eggs\"\r\n            .filter((c) => c !== undefined);\r\n\r\n          // there's no splits, but we can fake one to keep the upcoming logic cleaner\r\n          if (Object.keys(splits).length === 0) {\r\n            splits[\"\"] = true;\r\n          }\r\n\r\n          return Object.keys(splits).map((split, k) => {\r\n            // recalc a color id, factoring in the split offsets\r\n            const splitColorId = colorId + k;\r\n\r\n            return {\r\n              label: `${s.name} [${j}] ${split}`,\r\n              fill: false,\r\n              showLine: isMarker === false,\r\n              borderColor: colors[splitColorId],\r\n              backgroundColor: colors[splitColorId],\r\n              // is this a real split or nah (short-circuit)\r\n              data:\r\n                split === \"\"\r\n                  ? data\r\n                  : data.filter((d) => d && d.split && d.split === split),\r\n            };\r\n          });\r\n        });\r\n      })\r\n    );\r\n  }, [props]);\r\n\r\n  // render the line graph\r\n  return (\r\n    <div style={{ position: \"relative\", maxHeight: \"100vh\" }}>\r\n      <Line\r\n        data={{ datasets: data }}\r\n        options={{\r\n          downsample: {\r\n            onInit: false,\r\n            restoreOriginalData: false,\r\n            enabled: true,\r\n            threshold: 250, // max number of points to display per dataset\r\n          },\r\n          animation: {\r\n            duration: 0,\r\n          },\r\n          tooltips: {\r\n            callbacks: {\r\n              label: function (tooltipItem: any, data: any) {\r\n                var label = data.datasets[tooltipItem.datasetIndex].label || \"\";\r\n                var meta =\r\n                  data.datasets[tooltipItem.datasetIndex].data[\r\n                    tooltipItem.index\r\n                  ].meta;\r\n\r\n                if (label) {\r\n                  label += \": \";\r\n                }\r\n\r\n                if (meta) {\r\n                  label += JSON.stringify(meta) + \": \";\r\n                }\r\n\r\n                label += Math.round(tooltipItem.yLabel * 100) / 100;\r\n                return label;\r\n              },\r\n            },\r\n          },\r\n          scales: {\r\n            xAxes: [\r\n              {\r\n                type: \"time\",\r\n                distribution: \"series\",\r\n                offset: true,\r\n                ticks: {\r\n                  major: {\r\n                    enabled: true,\r\n                    fontStyle: \"bold\",\r\n                  },\r\n                  source: \"data\",\r\n                  autoSkip: true,\r\n                  autoSkipPadding: 75,\r\n                  maxRotation: 0,\r\n                  sampleSize: 100,\r\n                },\r\n              },\r\n            ],\r\n            yAxes: [\r\n              {\r\n                gridLines: {\r\n                  drawBorder: false,\r\n                },\r\n                scaleLabel: {\r\n                  display: false,\r\n                },\r\n              },\r\n            ],\r\n          },\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","import moment from \"moment\";\r\nimport { RegexResult, RegExpWithMarker } from \"./types\";\r\n\r\nexport const parseRegexResult = (\r\n  rex: RegExpWithMarker,\r\n  line: string\r\n): RegexResult | undefined => {\r\n  const re = rex.exec(line);\r\n\r\n  // markers don't need plot!\r\n  if (\r\n    !re ||\r\n    !re.groups ||\r\n    !re.groups.time ||\r\n    (!re.groups.plot && !rex._marker)\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  const { time, plot, split } = re.groups;\r\n  const meta: string[] = [];\r\n\r\n  for (let i = 1; i < re.length; i++) {\r\n    // skip data that's in a named group\r\n    if (\r\n      typeof re[i] !== \"undefined\" &&\r\n      (re[i] === time || re[i] === plot || re[i] === split)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    meta.push(re[i]);\r\n  }\r\n\r\n  const res: RegexResult = {\r\n    x: moment(time).toDate(),\r\n    y: plot,\r\n    split,\r\n    marker: rex._marker || false,\r\n    meta: meta.length > 0 ? meta : undefined,\r\n  };\r\n\r\n  return res;\r\n};\r\n","import * as React from \"react\";\r\n\r\ninterface Props {\r\n  onComplete: () => void;\r\n}\r\n\r\nexport default function Intro(props: Props) {\r\n  return (\r\n    <div>\r\n      <h1>Welcome to Textre!</h1>\r\n      <p>\r\n        Textre (pronounced texture) is a tool for extracting time series data\r\n        from raw text files, and visualizing it on a graph. I built it to help\r\n        me debug audio video call logs - but feel free to use it for whatever.\r\n      </p>\r\n      <h3>Getting Started</h3>\r\n      <ul>\r\n        <li>\r\n          <p>\r\n            First, you'll be asked to select a{\" \"}\r\n            <span style={{ fontWeight: \"bold\" }}>source</span> - sources are\r\n            just raw text files containing the content you want to select and\r\n            visualize.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            Then you'll define some{\" \"}\r\n            <span style={{ fontWeight: \"bold\" }}>regex</span> - regex tells us\r\n            how to understand your content.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            That's it! You'll be presented with{\" \"}\r\n            <span style={{ fontWeight: \"bold\" }}>the chart</span> - the chart is\r\n            the main view in this app, it shows all your time series data and\r\n            lets you interact with it.\r\n          </p>\r\n        </li>\r\n        <li>\r\n          <button onClick={() => props.onComplete()}>Begin!</button>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n","import * as React from \"react\";\nimport AddSource from \"./add-source\";\nimport AddRegex from \"./add-regex\";\nimport Graph from \"./graph\";\nimport Intro from \"./intro\";\nimport { DataSource, RegexSource } from \"./types\";\n\nimport \"./styles.css\";\n\nexport default function App() {\n  const [isOOBE, setIsOOBE] = React.useState<boolean>(true);\n  const [addSourceVisible, setAddSourceVisible] = React.useState<boolean>(true);\n  const [addRegexVisible, setAddRegexVisible] = React.useState<boolean>(true);\n  const [dataSources, setDataSources] = React.useState<DataSource[]>([]);\n  const [regexes, setRegexes] = React.useState<RegexSource[]>([]);\n\n  const addSources = React.useCallback(\n    (srcs: { name: string; data: string }[]) => {\n      setDataSources(dataSources.concat(srcs));\n    },\n    [dataSources]\n  );\n\n  const addRegex = React.useCallback(\n    (src: RegexSource) => {\n      setRegexes(regexes.concat([src]));\n    },\n    [regexes]\n  );\n\n  if (isOOBE) {\n    return <Intro onComplete={() => setIsOOBE(false)} />;\n  } else if (addSourceVisible) {\n    return (\n      <AddSource\n        registerSources={addSources}\n        onComplete={() => setAddSourceVisible(false)}\n      />\n    );\n  } else if (addRegexVisible) {\n    return (\n      <AddRegex\n        sources={regexes}\n        registerSource={addRegex}\n        onComplete={() => setAddRegexVisible(false)}\n      />\n    );\n  } else {\n    return (\n      <>\n        <div>\n          <span>\n            <button onClick={() => setAddSourceVisible(true)}>\n              Add Source [{dataSources.length}]\n            </button>\n          </span>\n          <span>\n            <button onClick={() => setAddRegexVisible(true)}>\n              Add Regex [{regexes.length}]\n            </button>\n          </span>\n          <span>\n            <button onClick={() => setRegexes([])}>Clear Regex</button>\n          </span>\n        </div>\n        <Graph datasources={dataSources} regexes={regexes} delim={\"\\n\"} />\n      </>\n    );\n  }\n}\n","import * as React from \"react\";\nimport { render } from \"react-dom\";\n\nimport App from \"./app\";\n\nconst rootElement = document.getElementById(\"root\");\nrender(<App />, rootElement);\n"],"sourceRoot":""}